<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CS144 项目文档 - Rust By Example</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Rust by Example (RBE) is a collection of runnable examples that illustrate various Rust concepts and standard libraries.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust By Example</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust-by-example" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="cs144-项目文档"><a class="header" href="#cs144-项目文档">CS144 项目文档</a></h1>
<h3 id="lab-0"><a class="header" href="#lab-0">LAB 0</a></h3>
<h4 id="21-fetch-a-web-page"><a class="header" href="#21-fetch-a-web-page">2.1 Fetch a Web page</a></h4>
<p>使用 telnet 发送 HTTP 报文获取网页内容</p>
<img src="/assets/JyY9bsnVXoM1GXxF3eqcSDz3nkf.png" src-width="1332" src-height="572" align="center"/>
<h4 id="22-send-yourself-an-email"><a class="header" href="#22-send-yourself-an-email">2.2 Send yourself an email</a></h4>
<p>使用telnet发送smtp报文来发送邮件</p>
<p>需要使用qq邮箱的 账户base编码，授权码的base编码</p>
<pre><code class="language-bash">qq邮箱账户base64编码：MTA0MDYwODA5MUBxcS5jb20=
qq邮箱授权码：fwvjmizgeplpbbda
授权码的base64编码：Znd2am1pemdlcGxwYmJkYQ==
</code></pre>
<p>结果：</p>
<img src="/assets/PYSxbAsDRoM1x4xXl53cN6uRnbf.png" src-width="599" src-height="551"/>
<img src="/assets/YZthbiT2boNhjuxEkxZcpBlonSb.png" src-width="519" src-height="276"/>
<p>参考文章：</p>
<ol>
<li><a href="https://blog.csdn.net/qq_40286920/article/details/126958507">CS144LAB0 实验过程 超详细_cs144实验-CSDN博客</a></li>
<li><a href="https://www.cnblogs.com/Fight-go/p/16187816.html">CS144计算机网络lab0: networking warmup</a></li>
<li><a href="https://blog.csdn.net/LostUnravel/article/details/124534172">[CS144] Lab 0: networking warmup_webget.cc-CSDN博客</a></li>
<li><a href="https://deepz.cc/2021/07/cs144-lab0/">Stanford CS144 Lab0 小结</a></li>
<li><a href="https://www.cnblogs.com/Last--Whisper/p/17269081.html">www.cnblogs.com</a></li>
</ol>
<h4 id="23-listening-and-connecting"><a class="header" href="#23-listening-and-connecting">2.3 Listening and connecting</a></h4>
<img src="/assets/FENpbFgbCo6znhxqJ9jcREyLn4d.png" src-width="1096" src-height="479" align="center"/>
<h4 id="34-writing-webget"><a class="header" href="#34-writing-webget">3.4 Writing webget</a></h4>
<p>lab 0的第一个task，比较简单，本地模拟浏览器发送http请求给服务器，然后接收服务端的响应</p>
<p>这里不是用的原生socket，而是使用的课程封装好的类，注意查阅相关的API文档，找到自己需要使用的函数</p>
<img src="/assets/WKEtbDYfTo9kM6xZuiycqNP5n6g.png" src-width="703" src-height="387"/>
<p>LAB 0 web_get的代码</p>
<pre><code class="language-cpp">// 客户端发出连接请求，与服务器建立连接
    TCPSocket sock;
    auto addr = Address(host,"http");
    sock.connect(addr);

    // 客户端send http请求报文
    sock.write("GET " + path + " HTTP/1.1\r\n");
    sock.write("Host: " + host + "\r\n");
    sock.write("Connection: close\r\n");
    sock.write("\r\n");
    sock.shutdown(SHUT_WR);  // 发送结束

    // 客户端recv 服务端的回应数据
    while(!sock.eof()) {
        auto recv_msg = sock.read();
        cout &lt;&lt; recv_msg;
    }
    sock.close();
</code></pre>
<h4 id="4-anin-memory-reliable-byte-stream"><a class="header" href="#4-anin-memory-reliable-byte-stream">4 Anin-memory reliable byte stream</a></h4>
<p>这部分的task还是比较简单的，我们需要使用一个数据结构来模拟字节流；考虑到字节流需要一端读，一端写，很容易想到队列，然后这里使用deque，因为相比于queue，它可以支持随机访问，方便peek操作</p>
<p>test的过程中，在几个地方出现了问题，最后逐一解决</p>
<p>问题1：end_input和input_ended函数，一开始以为就是end_input写一个cout提示，然后inpu_ended是根据buffer size和capacity来判断，后来发现实际上是writer end input发信号通知，然后reader input_ended根据信号判断，所以很明显使用一个flag来代表信号影响的变量</p>
<p>问题2：eof函数，eof我一开始的理解就是buffer为空就是eof，但是test一直不对，最后实在不行参考了别人eof的设计，发现不仅仅需要buffer为空，还需要停止输入，所以很显然需要加上flag一起判断</p>
<p>问题3：bytes_read，这个问题是理解错误，我一开始以为pop不需要统计bytes_read，后来发现需要，所以在里面统计即可，完美解决</p>
<img src="/assets/DBeFbnAApothJjx1KILc9vYkn5g.png" src-width="703" src-height="417"/>
<img src="/assets/LjsZbud7fokaTYxERfYcSEHknHp.png" src-width="661" src-height="423"/>
<h4 id="lab-0问题集合"><a class="header" href="#lab-0问题集合">lab 0问题集合</a></h4>
<h5 id="客户端初次ssh连接服务器"><a class="header" href="#客户端初次ssh连接服务器">客户端初次ssh连接服务器：</a></h5>
<p>The authenticity of host '[localhost]:2222 ([127.0.0.1]:2222)' can't be established.</p>
<p>ED25519 key fingerprint is SHA256:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</p>
<p>This key is not known by any other names</p>
<p>Are you sure you want to continue connecting (yes/no/[fingerprint])?</p>
<p>这是因为客户端第一次连接服务器，服务器的hostname和密钥还没有保存到客户端上，选择yes后，密钥和hostname会保存到客户端上，之后就是可信任的连接了</p>
<p>通过这个也可以顺便复习一下SSH加密的过程；</p>
<h5 id="virtualbox-屏幕尺寸调节"><a class="header" href="#virtualbox-屏幕尺寸调节">VirtualBox 屏幕尺寸调节：</a></h5>
<p>https://www.cnblogs.com/Braveliu/p/10131613.html</p>
<p>VirtualBox共享文件和粘贴的问题一直没有解决，更换虚拟机软件，选择使用VMware</p>
<p>导入课程打包的ova文件即可</p>
<p>https://zouzhongliang.com/index.php/2019/11/11/vmwarexunijidaoruxunixitongdangfangfaova-ovf/</p>
<h5 id="debug-getaddrinfocs144keithworg-http-temporary-failure-in-name-resolution"><a class="header" href="#debug-getaddrinfocs144keithworg-http-temporary-failure-in-name-resolution">debug： getaddrinfo(cs144.keithw.org, http): Temporary failure in name resolution</a></h5>
<p>代理问题，重新开一下代理，然后重启一下虚拟机就行</p>
<h5 id="git-clone仓库取别名"><a class="header" href="#git-clone仓库取别名">Git clone仓库取别名：</a></h5>
<p>git clone &lt;remote_repo_url&gt; local_dir_name</p>
<p><a href="https://cmderq.blog.csdn.net/article/details/101429831?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-101429831-blog-100982772.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-101429831-blog-100982772.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;utm_relevant_index=1">git克隆远程仓库指定分支，并在本地重命名_git clone 重命名-CSDN博客</a></p>
<h5 id="git-clone指定分支"><a class="header" href="#git-clone指定分支">Git clone指定分支：</a></h5>
<p>克隆仓库，获取所有分支，立即切换到指定的分支</p>
<pre><code>git clone -b &lt;branchname&gt; &lt;remote-repo-url&gt;
</code></pre>
<p>克隆仓库并仅获取一个分支</p>
<pre><code>git clone -b &lt;branchname&gt; --single-branch &lt;remote-repo-url&gt;
</code></pre>
<p><a href="https://www.freecodecamp.org/chinese/news/git-clone-branch-how-to-clone-a-specific-branch/">如何 Git Clone 指定分支</a></p>
<h5 id="no-member-named-cout-in-namespace-stdclangno_member"><a class="header" href="#no-member-named-cout-in-namespace-stdclangno_member">No member named 'cout' in namespace 'std'clang(no_member)</a></h5>
<p>忘记include &lt;iostream&gt;</p>
<h5 id="error-bytestreamq-should-be-initialized-in-the-member-initialization-list--werroreffc"><a class="header" href="#error-bytestreamq-should-be-initialized-in-the-member-initialization-list--werroreffc">error: ‘ByteStream::q’ should be initialized in the member initialization list [-Werror=effc++]</a></h5>
<p>现代C++，成员初始化必须要在初始化列表里</p>
<ol>
<li>[Can I ignore the gcc warning: ‘Foo::m_bar’ should be initialized in the member initialization list <a href="https://stackoverflow.com/questions/14002454/can-i-ignore-the-gcc-warning-foom-bar-should-be-initialized-in-the-member-i"></a></li>
<li><a href="https://www.linuxquestions.org/questions/programming-9/c-%27namefile-mylist%27-should-be-initialized-in-the-member-initialization-list-4175626743/">www.linuxquestions.org</a></li>
</ol>
<p>error：Field 'input_flag' will be initialized after field</p>
<ol>
<li><a href="https://stackoverflow.com/questions/1564937/gcc-warning-will-be-initialized-after">gcc warning" 'will be initialized after'</a></li>
<li><a href="https://www.cnblogs.com/studywithallofyou/p/14179065.html">www.cnblogs.com</a></li>
</ol>
<h4 id="lab-0参考资料"><a class="header" href="#lab-0参考资料">Lab 0参考资料</a></h4>
<ol>
<li>
<p>官方pdf
<a href="/assets/Zvvrb4EFvoApojxX34XcdAlRn6f.pdf">lab0.pdf</a></p>
</li>
<li>
<p><a href="https://doraemonzzz.com/2022/01/30/2022-1-30-CS144-Lab0%E7%BF%BB%E8%AF%91/">CS144 Lab0翻译</a></p>
</li>
<li>
<p><a href="https://lrl52.top/992/cs144-lablab-0/">CS144 Lab：Lab0 – LRL52 的博客</a></p>
</li>
<li>
<p><a href="https://github.com/LRL52/CS144-Sponge/tree/lab0-startercode">GitHub - LRL52/CS144-Sponge at lab0-startercode</a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/container/deque/deque">std::deque&lt;   T,Allocator&gt;   :: deque</a></p>
</li>
<li>
<p><a href="https://deepz.cc/2021/07/cs144-lab0/">Stanford CS144 Lab0 小结</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/Last--Whisper/p/17269081.html">Stanford CS 144, Lab 0: networking warmup 实验</a></p>
</li>
</ol>
<h4 id=""><a class="header" href="#"></a></h4>
<h3 id="lab-1"><a class="header" href="#lab-1">LAB 1</a></h3>
<h4 id="git相关操作调整代码仓库"><a class="header" href="#git相关操作调整代码仓库">git相关操作，调整代码仓库</a></h4>
<ol>
<li>clone远程仓库，然后本地创建同名分支和远程分支一一对应</li>
<li>本地仓库的master分支回滚到lab0-startercode的commit；</li>
<li>之后取消本地仓库和clone仓库的远程关联，添加自己的github远程仓库</li>
<li>将本地仓库的所有分支push到自己的远程仓库中</li>
<li>之后的开发就是在master分支上开发，每做一个lab就merge远程分支的对应分支到master分支上</li>
</ol>
<img src="/assets/MhoSbuiGIoXV2hxwg5ScVNoDnGd.png" src-width="1143" src-height="651" align="center"/>
<img src="/assets/VIvBb7kLCorVpPxjgq7cN4Psn6c.png" src-width="962" src-height="568" align="center"/>
<img src="/assets/Zrz6bRHTQoKhWxxqfxTc80Danlb.png" src-width="635" src-height="288"/>
<img src="/assets/SBuqbkPE2oZmjKxs2kHc4pKmnNl.png" src-width="876" src-height="171" align="center"/>
<h4 id="lab-1思路与实现"><a class="header" href="#lab-1思路与实现">Lab 1思路与实现</a></h4>
<p>看了很多相关的资料，最后大致有了自己的理解</p>
<p>Lab 0我们实现了byte stream，其实就是一个支持读写字符串的buffer，但是到达的数据有可能是乱序的，所以我们希望在写入byte stream之前进行重组，保证数据是有序的，再传入底层的byte stream里；</p>
<p>所以lab 1里继续在byte stream的基础上进行封装，需要实现一个reassembler类，这个类里封装了byte stream对象，以及相关的重组相关的实现；</p>
<p>为了实现reassembler（重组器）类，我们主要是参照下面的这幅图进行实现</p>
<img src="/assets/PP54bak2yoUDsyxtxdOcQ2ZenDe.png" src-width="707" src-height="454"/>
<p>重组器（reassembler）对于接收到的字节流，重组器需要维护一个滑动窗口（buffer，初始size是capacity），窗口从左到右滑动对字节流进行读取，窗口内的数据重组有序后，写入底层的ByteStream里（此时窗口的大小就自然变小了，size = capacity - bytestream.size(), 窗口左端向右移动，first_unassembled变大），然后ByteStream里再被上层继续读取（此时窗口的大小恢复，size = capacity，窗口右端向右移动，first_unacceptable更新变大)；重组器通过滑动窗口这种方式，把字节流读取完；</p>
<p>根据这幅图我们可以看出，对于一个字节流就可以分为四段</p>
<p>[start(0), first unread)：蓝色段，已经从重组器的窗口滑出，并且也已经从bytestream里read</p>
<p>[first unread, first unassembled)：绿色段，已经从重组器的窗口滑出（意味已经重组排序），进入bytemstream</p>
<p>[first unassembled, first unacceptable): 红色段，在重组器的窗口里（意味还没有重组排序）</p>
<p>[first unacceptable, ...): 超出了窗口的范围，不能被重组器读取</p>
<p>capacity的含义：byte stream的size + 窗口的size</p>
<p>网上很多实现，用的是一个固定大小的滑动窗口，size = capacity，但是本质上这个窗口并不是一个固定的滑动窗口，它只是初始情况/最大情况下为capacity，窗口buffer和bytestream其实是共用的capacity，只是初始情况下和byte stream为空的情况下，窗口的size为capacity！</p>
<p>大体实现思路：</p>
<p>逻辑实现上，我们维护一个capacity的buffer对应初始化的最大窗口（因为upboud是capacity)，根据[first_unassembled, first_unaccepted)对接收的substring进行截断，[first_unassembled, first_unaccepted)区间才是实际的滑动窗口，然后我们需要把窗口内的数据都放入buffer中，然后从buffer的第一位看起，找连续的字符串，找到了就说明这些字符串重组完成，这时候就可以写入byte stream里，写完之后窗口进行滑动，first_unassembled变大，unassembled_bytes也会减少；</p>
<p>eof的判断需要深度理解，重组器eof 由两个条件决定</p>
<p>条件1：带有eof标志的substring已经接收过</p>
<p>条件2：带有eof标志的substring的最后一位包括之前的都已经经过重组，写入了bytestream中；</p>
<p>buffer的数据结构，应该选用一个支持随机访问的数据结构用来模拟窗口，所以vector，deque，string都行</p>
<p>substring截断进入buffer的逻辑，可以分类讨论，也可以直接算出最终写入窗口的[start, end)</p>
<p>debug1: eof判断出错</p>
<img src="/assets/DYnPbNDXCoEBM2xC73xcatd5n9e.png" src-width="910" src-height="249" align="center"/>
<p>解决：debug了半个晚上，总算pass了，问题出case1没有判断eof直接return了，所以在case1前加多判断一次，保证case1的情况也可以进行eof判断；</p>
<p>然后对于case 2和case 3会存在写入byte stream的操作，所以窗口会发生变化，所以即使之前判断了一次eof，但是窗口变化之后还需要再判断eof，一定要用窗口更新后的first_unassembled进行判断；</p>
<p>实验结果：100%，效率不错！</p>
<img src="/assets/Et6cbKtBKoRJ3expJ3jcyxtVnWd.png" src-width="867" src-height="645" align="center"/>
<p>实现的参考：</p>
<ol>
<li><a href="https://github.com/PKUFlyingPig/CS144-Computer-Network">GitHub - PKUFlyingPig/CS144-Computer-Network: Learning materials for Stanford Computer Network cours</a></li>
<li><a href="https://luolibrary.com/2022/11/21/CS144-Introduction-to-Computer-Networking-Lab-1/">CS144: Introduction to Computer Networking Lab 1</a></li>
<li><a href="https://deepz.cc/2021/07/cs144-lab1/">Stanford CS144 Lab1 小结</a></li>
<li><a href="https://lrl52.top/996/cs144-lablab1/">CS144 Lab：Lab1 – LRL52 的博客</a></li>
</ol>
<h4 id="lab-1问题集合"><a class="header" href="#lab-1问题集合">Lab 1问题集合</a></h4>
<h5 id="git-merge的时候跳出nano编辑器"><a class="header" href="#git-merge的时候跳出nano编辑器">Git merge的时候跳出nano编辑器：</a></h5>
<ol>
<li><a href="https://blog.csdn.net/weixin_44166997/article/details/93216783">GNU nano使用保存退出的说明_gnu nano如何保存退出-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_29230261/article/details/81454101">使用nano时怎么保存退出的问题_nano怎么保存退出-CSDN博客</a></li>
</ol>
<h4 id="lab-1参考资料"><a class="header" href="#lab-1参考资料">Lab 1参考资料</a></h4>
<p>视频类：</p>
<ol>
<li><a href="https://www.bilibili.com/video/BV1mt4y177AJ/?spm_id_from=333.880.my_history.page.click">CS144. 计算机网络实验. Lab1. 重排器与滑动窗口协议_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1vB4y1S7v7/?vd_source=cb02f779bd17a3aad9801e0c4464dfc9">速通cs144 手撕tcp协议_哔哩哔哩_bilibili</a></li>
</ol>
<p>文档类：</p>
<ol>
<li>
<p>官方pdf
<a href="/assets/ROlQb0FIXoendRxp2u1cAtcgnDf.pdf">lab1.pdf</a></p>
</li>
<li>
<p><a href="https://doraemonzzz.com/2022/01/30/2022-1-30-CS144-Lab1%E7%BF%BB%E8%AF%91/">CS144 Lab1翻译</a></p>
</li>
<li>
<p><a href="https://kiprey.github.io/2021/11/cs144-lab1/">CS144计算机网络 Lab1 | Kiprey's Blog</a></p>
</li>
<li>
<p><a href="https://github.com/PKUFlyingPig/CS144-Computer-Network">GitHub - PKUFlyingPig/CS144-Computer-Network: Learning materials for Stanford Computer Network cours</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/m0_56649715/article/details/128810228">CS144 计算机网络 lab1_cs144lab1-CSDN博客</a></p>
</li>
<li>
<p><a href="https://luolibrary.com/2022/11/21/CS144-Introduction-to-Computer-Networking-Lab-1/">CS144: Introduction to Computer Networking Lab 1</a></p>
</li>
<li>
<p><a href="https://deepz.cc/2021/07/cs144-lab1/">Stanford CS144 Lab1 小结</a></p>
</li>
<li>
<p><a href="https://lrl52.top/996/cs144-lablab1/">CS144 Lab：Lab1 – LRL52 的博客</a></p>
</li>
<li>
<p><a href="doxcnpBEN4SG3vA9pVyCoANigBh">计算机网络学习笔记-CS144</a></p>
</li>
</ol>
<h3 id="lab-2"><a class="header" href="#lab-2">LAB 2</a></h3>
<img src="/assets/BRllb1Kvmowc3VxQqoQc9qg8nnh.png" src-width="1230" src-height="349"/>
<img src="/assets/MYBnbGfzqou1ilx2TXuc2wTinvc.png" src-width="780" src-height="72"/>
<h4 id="part1"><a class="header" href="#part1">part1</a></h4>
<p>实现wrap和unwrap</p>
<p>wrap是把absolute seqno -&gt; seqno，abs_seqno是64位的，然后seq_no是32位的，所以转化的时候会出现多对一，但不会出现一对多；所以可以直接转化，无符号数的溢出环绕行为，相当于自动取模；</p>
<p>Seqno = (abs_seqno + isn) % mod32 = abs_seqno % mod32 + isn % mod32 = abs_seqno % mod32 + isn;</p>
<p>溢出，类型转化都相当于自动取模；</p>
<p>unwrap是把seqno -&gt; absolute seqno，很明显小值域映射到大值域，会出现一对多的情况，这个时候我们需要一个checkpoint，选择离checkpoint最近的作为我们的结果；具体怎么操作呢，我们首先将checkpoint从abs_seq转化到seqno，然后计算n 和 转化过的checkpoint的offset，然后在abs_seqno的值域中，我们将checkpoint + offset，得到的就是结果；这里需要详细考虑溢出的操作</p>
<h4 id="part2"><a class="header" href="#part2">part2</a></h4>
<p>主要实现 几个部分</p>
<p>ackno：ack是什么意思呢，ack意味着 [isn, ack)这一部分全部已经被接收了，也就是说ack之前的全部都是有序的，所以很明显ackno就是之前lab1里所指的first_unassembled，first_unassembled之前的数据都已经有序，并且写入了底层的bytestream中，所以first_unassembled = bytestream.bytes_write();</p>
<p>文档中告诉了我们，receiver有三种状态</p>
<ol>
<li>没有收到syn，此时ackno没有值</li>
<li>已经收到syn，还没有收到fin，此时ackno = wrap(first_unassembled + 1)</li>
<li>收到fin，此时ackno = wrap(first_unassembeld + 1 + 1)</li>
</ol>
<p>Window size：在lab1中我们分析过，capacity实际就是bytestream和window的共同大小，初始情况下bytemstream为空，window = capacity；之后读取字符流，读进window，重组后再写入bytestream里，此时window就会减小，然后bytestream里的数据read后，bytestream的大小减小，此时window就又会增大，我们通过这样的方式来滑动窗口，持续接收数据；</p>
<p>而且上面的注释也提示了 window size = capacity - bytestream.size(); 因为bytestream和window实际上是共用的capacity，他们的上限都是capacity，所以window size = bytemstream.remaining_capacity()</p>
<h4 id="lab2-参考资料"><a class="header" href="#lab2-参考资料">lab2 参考资料</a></h4>
<p>视频类：</p>
<ol>
<li><a href="https://www.bilibili.com/video/BV1mK411f7B1/?spm_id_from=333.788&amp;vd_source=cb02f779bd17a3aad9801e0c4464dfc9">CS144. 计算机网络实验. Lab2. TCP的接收端_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.bilibili.com/video/BV1vB4y1S7v7/?vd_source=cb02f779bd17a3aad9801e0c4464dfc9">速通cs144 手撕tcp协议_哔哩哔哩_bilibili</a></li>
</ol>
<p>文档类：</p>
<ol>
<li>
<pre><code>[lab2.pdf](/assets/MoqLbKewsoE5yAxtI6gcp2Gennj.pdf)
</code></pre>
</li>
<li>
<p><a href="https://doraemonzzz.com/2021/12/27/2021-12-27-CS144-Lab2%E7%BF%BB%E8%AF%91/">CS144 Lab2翻译</a></p>
</li>
</ol>
<h3 id="lab-3"><a class="header" href="#lab-3">LAB 3</a></h3>
<p>(1) 开始lab3前，当然是要好好阅读文档！</p>
<p>以下链接 提供了lab3的英文文档，以及基本的中文讲解</p>
<p>https://kiprey.github.io/2021/11/cs144-lab3/</p>
<p>(2) lab3的要求大概了解了，主要就是说完成两个部分</p>
<ol>
<li>将数据流封装成segment，然后发送到队列里去</li>
<li>发送端超时重传的逻辑</li>
</ol>
<p>这里给出一些我参考过的资料，去理解这两个部分</p>
<p>大佬1的CS144 lab讲解：https://space.bilibili.com/697699241</p>
<p>大佬2的CS144 lab讲解：https://www.bilibili.com/video/BV1n24y1Z7yi/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cb02f779bd17a3aad9801e0c4464dfc9</p>
<h4 id="蜡笔"><a class="header" href="#蜡笔">蜡笔</a></h4>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../首页/supported-formats.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../算法备忘录.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../首页/supported-formats.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../算法备忘录.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
